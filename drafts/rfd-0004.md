---
authors: Graeme Jenkinson <gcj21@cl.cam.ac.uk>
state: draft
---

<!-- 
	This document is subject to the terms of BSD 2 Clause License.
    See LICENSE in this repository for more information.

    Copyright 2017 Graeme Jenkinson
-->

# RFD 004 UUIDv5 naming of aggregations and enablings

## Problem Statement

Local names are ubiquitious in DTrace.
Currently, DTrace identifies both aggregations (`dtrace_aggid_t`) and enablings
(`dtrace_epid_t`) with simple numerical identifiers (32-bit unsigned integers).
The values of these identifiers depends on the current kernel state.  For
example, aggregation identifiers are assigned by a kernel unit allocator
(`vmem_alloc()` on Illumos and `alloc_unr()` on FreeBSD). The value returned by
the allocator is clearly dependent on the previously allocated/freed values,
which in turn depends on the current DTrace enablings. This is problematic in
a distributed setting as no guarantees are provided that the same
aggregation computed across a set of machines will be identified consitently.

Similarly to aggregations, DTrace enablings are identified by a monotonically
increasing numerical identifier of type `dtrace_epid_t` (an unsigned 32-bit
integer) and as a result the same enabling on a different machine can posses a
completly different identifier. The enabling's identifier determines the
semantics of a given trace record. Using different identifiers where records
posses the same semantics (and syntax) adds unecessary complexity.

We propose that, as a foundation for distributed tracing, DTrace is extended
to identify aggregations and enablings with a v5 128-bit UUID. As UUIDs impose
an additional 96-bit overhead per trace record, using UUID-based identifiers will
be enabled through an additional option to the `dtrace` command line tool.

An aggregation's UUID will be created based on a name, formed by concatenating 
a unique namespace, the aggregation's name and the components of its key.
For example, the aggregation `@a[probefunc, arg0]` results in a UUID based on
a hash as follows: `h(namespace|a|probefunc|arg0)` (Note although it isn't
possible to have the same name for an aggregation with different keys on a single
machine. Machines in a distributed system could have an aggregation with the same
name but with different keys: `@b[probefunc]`, `@b[probefunc, arg0]`.)

DTrace probes will be uniquely identified by both the traditional name tuple
`provider:module:function:name` and also by their predicates (`h(namespace|nametuple|predicate)`).
As with aggregations, probes will be named in a uniquely specified namespace.

(Currently DTrace allow probes to be defined with exactly the same name and
predicate; resulting in the same UUID. This may be problematic for the dynamic isntallation
and removal of probes. How should this be addressed?)
   
## User Visibility

A new option will be added to the `dtrace` command to enable UUID-based naming. 

We propose that aggregations and enablings identifiers are created within a unique namespace.
The namespace allows identical aggregations and enablings to be processed
differently and also identifies separate streams of records in the trace buffer;
similarly to the use of the trace UUID in the Common Trace Format [1]. The
user will specify the namespace (as either a UUID or textual name) in the submitted D script.

The trace namespace could be extended in the D langauge as follows:

```
namespace 6ba7b814-9dad-11d1-80b4-00c04fd430c8 {

	syscall:::entry {
	}

}
```

alternatively a textual name could be used when specifying the namespace
(this value is hashed to derive a UUIDv5 identifier used as the namespace for identifying the
contained aggregations and enablings):

```
namespace cadets-trace {

	syscall:::entry {
	}
}
```

It is also envisaged that the namespace may indicate sets of probes that are to be handled 
differently. For example, in a distributed system the namespace may specify a set
of probes that are used to instrument database or webservers. Similarly the namespace
could indicate that the probes are installed in a guest virtual machine:

```
# Default namespace
fbt::vm_fault:entry {
  ....
}

namespace db {

	syscall::open:entry {
	   ...
	}
}
```

Other examples may be machines running different operating systems or different version of the 
same operating system.

```
namespace old_version {

	fbt::function_old_name:entry {
	  ....
	}
}

namespace new_version {

	fbt::function_new_name:entry {
	   ...
	}
}
```

It is possible that namespace is the wrong term for the scoping of a set of probes.
An alternative view is that probes are being added to a set (`probeset`),
and each set of probes may be handled differently.

```
probeset cadets {

	[probe] syscall::open:entry
	{
	   ...
	}
}
```

## Public Interfaces

The proposed changes have no forseen impact on public interfaces.

## Private Interfaces

Various changes to the D compiler will be needed to extend the D language to
become namespace aware. Further investigation is required once the exact
mechanism has been agreed upon.

## Upgrade Impact

The proposed changes have no forseen impact on code or scripts from earlier versions.

## Security Impact

The proposed changes have no forseen security impact.

## References

[1] The Common Trace Format. http://diamon.org/ctf/
