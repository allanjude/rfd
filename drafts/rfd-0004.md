---
authors: Graeme Jenkinson <gcj21@cl.cam.ac.uk>
state: draft
---

<!-- 
	This document is subject to the terms of BSD 2 Clause License.
    See LICENSE in this repository for more information.

    Copyright 2017 Graeme Jenkinson
-->

# RFD 004 UUIDv5 naming of aggregations and enablings

## Problem Statement

Currently, DTrace identifies both aggregations (`dtrace_aggid_t`) and enablings
(`dtrace_epid_`) with simple numerical identifiers (32-bit unsigned integers).
The values of these identifiers depends on the current kernel state.  For
example, aggregation identifiers are assigned by a kernel unit allocator
(`vmem_alloc()` on Illumos and `alloc_unr()` on FreeBSD). The value returned by
the allocator is clearly dependent on the previously allocated/freed values,
which in turn depends on the current DTrace enablings. This is problematic in
a distributed setting as, for example, no guarantess are provided that the same
aggregation computed by different machines will be named consitently.

Similarly to aggregations, DTrace enablings are named by a monotonically
increasing numerical identifier of type `dtrace_epid_t` (an unsigned 32-bit
integer) and as a result the same enabling on a different machine can posses a
completly different identifier. The enablings identifier determine the
semantics of a given trace record. Using different inditifiers where records
posses the same semnatics (and syntax) adds unecessary complexity.

We propose that, as a foundation for distributed tracing, DTrace is extended
to identify aggregations and enablings with a v5 128-bit UUID. As this imposes
a additional 96-bit overhead per trace, using UUID-based indentifies will
be enabled through an additional option to the `dtrace` command line tool.

An aggregation UUID will be created based on a name, formed from concatenating 
a unique namespace, the aggregation's name and the components of its key (note,
it may be that only the aggregation name is needed as two aggregations with the 
same name and different keys cannot be created).
For example, the aggregation `@a[probefunc, arg0]` results in a UUID based on
a hash as follows: `h(namespace|a|probefunc|arg0)`.

Probes will be uniquely idnetified by both the traditional name tuple
`provider:module:function:name` and also by their predicates. As with
aggregations, probes will be named in a uniquely specified namespace.
   
## User Visibility

A new option will be added to the `dtrace` command to enable 128-bit UUID-based
naming. 

We propose that aggregations and enablings are created within a unique namespace. The
namespace allows identical aggregations and enablings to be processed
differently and also identifies separate streams of records in the trace buffer;
similarly to the use of the trace UUID in the Common Trace Format [1]. The
user will specify the namespace (as either a UUID or textual name) in the submitted D script.

The trace namespace could be extended in the D langauge as follows:

```
namespace 6ba7b814-9dad-11d1-80b4-00c04fd430c8 {

	syscall:::entry {
	}

}
```

alternatively a textual name could be used when specifying the namespace
(this value is hashed to derive a UUID used as the namespace for identifying the
contained aggregations and enablings):

```
namespace cadets-trace {

	syscall:::entry {
	}
}
```

## Public Interfaces

The proposed changes have no forseen impact on public interfaces.

## Private Interfaces

Various changes to the D compiler will be needed to extend the D language to
become namespace aware. Further investigation is required once the exact
mechanism has been agreed upon.

## Upgrade Impact

The proposed changes have no forseen impact on code or scripts from earlier versions.

## Security Impact

The proposed changes have no forseen security impact.

## References

[1] The Common Trace Format. http://diamon.org/ctf/
